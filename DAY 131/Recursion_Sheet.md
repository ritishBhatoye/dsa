## Recursion Sheet

1. Print 1 to N and N to 1 using recursion  *(5–10 min)*  
2. Sum of first N natural numbers (recursive)  *(5–10 min)*  
3. Factorial of N (recursive)  *(5–10 min)*  
4. Power function \(a^b\) (linear recursion)  *(10–15 min)*  
5. Power function \(a^b\) (logarithmic fast power)  *(15–20 min)*  
6. Reverse an array / string using recursion  *(10–15 min)*  
7. Check if a string is palindrome (recursive)  *(10–15 min)*  
8. Count occurrences of an element in array (recursive)  *(10–15 min)*  
9. Print all indices of a target in array (recursive)  *(15–20 min)*  
10. Generate Fibonacci numbers using recursion  *(10–15 min)*  

11. Print all subsequences of an array / string  *(25–35 min)*  
12. Print all subsequences whose sum is K  *(25–35 min)*  
13. Count subsequences whose sum is K  *(25–35 min)*  
14. First subsequence whose sum is K (stop on first)  *(25–35 min)*  
15. Subset sum problem (exists or not)  *(25–35 min)*  
16. Generate all subsets (power set) of an array  *(25–35 min)*  
17. Generate all subsets with duplicates (unique subsets)  *(30–40 min)*  
18. Generate all permutations of an array / string  *(30–40 min)*  
19. Unique permutations with duplicates in input  *(35–45 min)*  
20. K-th permutation sequence of numbers 1..N  *(35–45 min)*  

21. Combination Sum I (unbounded choice)  *(30–40 min)*  
22. Combination Sum II (each element once, handle duplicates)  *(35–45 min)*  
23. Combination Sum III (fixed length K, numbers 1–9)  *(30–40 min)*  
24. Letter Combinations of a Phone Number  *(30–40 min)*  
25. Generate all valid parentheses of length 2N  *(30–40 min)*  
26. Subsets / combinations with constraints (e.g. size K)  *(30–40 min)*  

27. Rat in a Maze (all paths)  *(35–45 min)*  
28. Rat in a Maze with obstacles  *(35–45 min)*  
29. N-Queens (print all solutions)  *(45–60 min)*  
30. N-Queens (count solutions)  *(35–45 min)*  
31. Sudoku Solver (9x9 board)  *(60–90 min)*  
32. Word Search in a grid (existence of path spelling word)  *(35–45 min)*  
33. Word Search II (multiple words using trie + backtracking)  *(60–90 min)*  
34. M-Coloring Problem (graph coloring)  *(45–60 min)*  
35. Hamiltonian Path / Cycle in a graph (backtracking)  *(60–90 min)*  

36. Generate all binary strings of length N  *(20–30 min)*  
37. Generate all strings of length N with K ones  *(25–35 min)*  
38. Gray code sequence generation  *(30–40 min)*  
39. Josephus problem (recursive solution)  *(30–40 min)*  
40. Tower of Hanoi (minimal moves and print moves)  *(30–40 min)*  

41. Recursively reverse a linked list  *(25–35 min)*  
42. Check if a linked list is palindrome using recursion  *(30–40 min)*  
43. Flatten a multilevel linked list using recursion  *(35–45 min)*  

44. Height / depth of a binary tree (recursive DFS)  *(15–20 min)*  
45. Count nodes and leaf nodes in a tree  *(15–20 min)*  
46. Preorder / Inorder / Postorder traversals (recursive)  *(20–30 min)*  
47. Check if two trees are identical  *(20–30 min)*  
48. Check if a tree is height-balanced (AVL-style)  *(25–35 min)*  
49. Diameter of a binary tree (optimized recursion)  *(30–40 min)*  
50. Lowest Common Ancestor in a binary tree / BST  *(30–40 min)*  
51. Path from root to a given node  *(25–35 min)*  
52. All root-to-leaf paths with sum = K  *(30–40 min)*  
53. Path sum problems (exists / count / list all)  *(30–40 min)*  

54. Generate all expressions from digits that evaluate to target (add, subtract, multiply)  *(60–90 min)*  
55. Restore IP Addresses from string  *(35–45 min)*  
56. Palindrome Partitioning I (all partitions)  *(35–45 min)*  
57. Palindrome Partitioning II (min cuts – recursion + DP optimization)  *(45–60 min)*  
58. Partition to K equal-sum subsets (backtracking)  *(60–90 min)*  

59. Basic memoization patterns (Fibonacci, grid paths, climbing stairs)  *(25–35 min)*  
60. Count unique paths in an \(m \times n\) grid (recursive + memo)  *(30–40 min)*  
61. Minimum cost path in grid (recursive + memo)  *(35–45 min)*  
62. Edit Distance (recursive, then memoized)  *(45–60 min)*  
63. Longest Common Subsequence (recursive, then memoized)  *(45–60 min)*  

64. Design your own recursion tree and recurrence for at least 10 of the above problems and derive time complexity  *(open-ended)*  

